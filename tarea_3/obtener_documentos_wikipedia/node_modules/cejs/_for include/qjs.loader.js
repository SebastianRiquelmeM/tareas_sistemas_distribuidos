/**
 * @name framework loader for QuickJS.
 * 
 * @example
 * 
 * for including: <code>


</code>
 * 
 * @since
 * @see https://bellard.org/quickjs/
 * @see https://github.com/mengmo/QuickJS-Windows-Build
 */

// import statement must place at the beginning of the script.
import * as std from 'std';
import * as os from 'os';

'use strict';

// ---------------------------------------------------------------------//

Function('return this')().CeL = {
	// main lib path relative to the loader script.
	library_path : '../ce.js'
};

(function() {
	// 若非 absolute path，則將之改為 absolute path，
	// 否則 setup_library_base_path() 會抓不到。
	if (!/^([A-Z]:)?[\\\/]/i.test(CeL.library_path))
		// 這裡 os.getcwd()[0] 是 loader 本身之 path。
		CeL.library_path = os.getcwd()[0].replace(/[^\\\/]+$/, CeL.library_path
				.replace(/^..\//, ''));
	// CeL.library_path = os.realpath(CeL.library_path)[0];
	// console.log(CeL.library_path);

	var main_script_file = std.open(CeL.library_path, 'r');
	main_script_file.seek(0, std.SEEK_END);
	var main_script_file_size = main_script_file.tell();
	// console.log(main_script_file_size);

	var script_code = [],
	// http://nodejs.org/api/fs.html#fs.readFileSync
	main_lib_binary_buffer = new ArrayBuffer(main_script_file_size);
	main_script_file.seek(0, std.SEEK_SET);
	// console.log(main_script_file.tell());
	main_script_file.read(main_lib_binary_buffer, 0, main_script_file_size);
	// console.log(main_script_file.tell());

	var main_lib_binary = new Uint8Array(main_lib_binary_buffer);
	// console.log(main_lib_binary.slice(0,30));
	// pass the first 2 bytes (BOM)
	var i = 2, l =
	// 10
	main_script_file_size;
	// console.log(main_lib_binary.slice(0,800));

	if (false)
		console.log([ CeL.library_path, typeof main_lib_binary.length,
				main_lib_binary.length ]);

	// a simplified .get_file() for UTF-32.
	for (; i < l;) {
		var char_code = main_lib_binary[i++] + 256 * main_lib_binary[i++];
		// console.log(main_lib_binary[i] + ',' + main_lib_binary[i + 1]);
		script_code.push(String.fromCharCode(char_code));
	}

	CeL.library_code = script_code.join('');

	if (false) {
		console.log(script_code.length);
		// console.log(script_code.slice(0, 30));
		// console.log(CeL.library_code.slice(0, 30));
		console.log('[' + CeL.library_code.slice(0, 300)
		// .replace(/[\x00-\x1f]/g, '.')
		.replace(/[\u0100-\uffff]/g, '.')
		// .charCodeAt(0)
		+ ']');
	}

})();

// 2020/5/1 18:38:19 failed
std.evalScript(CeL.library_code);
if (false || 1) {
	console.log('CeL === globalThis.CeL: ' + (CeL === globalThis.CeL));
	console.log('typeof CeL: ' + typeof CeL);
	console.log('CeL: ' + CeL);
	console.log('CeL.set_debug: ' + CeL.set_debug);
}

// delete cache.
delete CeL.get_old_namespace().script_code;

// CeL.run('application.platform.nodejs', 'data.CSV');

if (false && typeof CeL === 'function') {
	CeL.set_debug();

	if (false)
		console.log(CeL.get_file('data.js').slice(0, 300).replace(
				/[\u0100-\uffff]/g, '.'));

	CeL.run('data.math', function() {
		var n1 = 123, n2 = 234;
		CeL.log('GCD(' + n1 + ', ' + n2 + ') = ' + CeL.GCD(n1, n2));
	});
}
