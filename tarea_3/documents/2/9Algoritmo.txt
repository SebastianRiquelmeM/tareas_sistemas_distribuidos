9Algoritmo.txt
{{distinguir|Logaritmo}}
[[Archivo:LampFlowchart-es.svg|thumb|Los [[diagrama de flujo|diagramas de flujo]] sirven para representar algoritmos de manera gráfica]]
[[Archivo:Diagram for the computation of Bernoulli numbers.jpg|thumb|Diagrama de [[Ada Lovelace]] de la "nota G", el primer algoritmo informático publicado]]

En [[matemáticas]], [[lógica]], [[ciencias de la computación]] y disciplinas relacionadas, un '''algoritmo''' (del [[latín]] ''algorithmus'' y este del [[griego antiguo|griego]] ''arithmos'', que significa «número», quizá también con influencia del nombre del matemático persa [[Al-Juarismi]])<ref name="Brassard">{{Cita libro |apellidos=Brassard, Gilles; Bratley, Paul |título=Fundamentos de Algoritmia |año=1997 |editorial=Madrid: PRENTICE HALL |isbn = 84-89660-00-X}}</ref> es un conjunto de instrucciones o reglas definidas y no-ambiguas, ordenadas y finitas que permite, típicamente, solucionar un problema, realizar un cómputo, procesar datos y llevar a cabo otras tareas o actividades.<ref name="rae">[http://buscon.rae.es/draeI/SrvltGUIBusUsual?TIPO_HTML=2&TIPO_BUS=3&LEMA=algoritmo Real Academia Española. Diccionario de la lengua española] "''Conjunto ordenado y finito de operaciones que permite hallar la solución de un problema.''" </ref> Dado un estado inicial y una entrada, siguiendo los pasos sucesivos se llega a un estado final y se obtiene una solución. Los algoritmos son el objeto de estudio de la '''algoritmia'''.<ref name="Brassard" />

En la vida cotidiana, se emplean algoritmos frecuentemente para resolver problemas determinados. Algunos ejemplos son los manuales de usuario, que muestran algoritmos para usar un aparato, o las instrucciones que recibe un trabajador de su [[empleador|patrón]]. Algunos ejemplos en [[matemática]] son el [[algoritmo de multiplicación]], para [[cálculo|calcular]] el producto, el algoritmo de la [[División (matemáticas)|división]] para calcular el cociente de dos números, el [[algoritmo de Euclides]] para obtener el [[máximo común divisor]] de dos [[Números enteros|enteros]] positivos, o el [[eliminación de Gauss-Jordan|método de Gauss]] para resolver un [[sistema de ecuaciones lineales]].

En términos de programación, un algoritmo es una secuencia de pasos lógicos que permiten solucionar un problema.
<!--
PROBLEMA -> ALGORITMO -> PROGRAMA

El [[pseudocódigo]] es una herramienta algorítmica que permite escribir pseudoprogramas (una imitación de un programa real) utilizando un lenguaje de pseudoprogramación que es una imitación de los lenguajes de programación de alto nivel. Así, un pseudocódigo es una combinación de símbolos (+, -, *, /, %, >, >=, <, <=, !=, ==, y, o, no), términos (Leer, Imprimir, Abrir, Cerrar, Hacer...Mientras, Mientras...Hacer, Para...Mientras, etc) y otras características comúnmente utilizadas en uno o más lenguajes de alto nivel.

No existen reglas que determinen que es o no es un pseudocódigo, sino que varía de un programador a otro. El objetivo del pseudocódigo es permitir al programador centrarse en los aspectos lógicos de la solución evitando las reglas de sintaxis de un lenguaje de programación. Posteriormente el pseudocódigo debe ser traducido a programa usando un lenguaje de programación de alto nivel como Java, C++, C, etc.
Ejemplo 2.1:- Diseñe un algoritmo para preparar una limonada. <br>
INICIO <br>
Llenar una jarra con un litro de agua <br>
Echar el jugo de tres limones <br>
Echar cuatro cucharadas de azúcar <br>
Remover el agua hasta disolver completamente el azúcar <br>
FIN <br>

Ejemplo 2.2 :- Diseñe un algoritmo que permita hallar la suma y el promedio de tres números. <br>

INICIO<br>
LEER numero1, numero2, numero3<br>
suma = numero1 + numero2 + numero3<br>
promedio = suma / 3<br>
IMPRIMIR suma, promedio<br>
FIN<br>

Notas:-

* El témino LEER significa obtener un dato de algún dispositivo de entrada, como el teclado, y almacenarlo en una variable.
Una variable es una localización en la memoria que tiene un nombre y cuyo contenido puede cambiar a lo largo de la ejecución de un programa. Así numero1, numero2 y numero3 son variables.
* El término IMPRIMIR significa mostrar el valor de una variable en algún dispositivo de salida, como la pantalla.
-->

== Definición ==
En general, no existe ningún consenso definitivo en cuanto a la definición formal de algoritmo. Muchos autores los señalan como listas de instrucciones para resolver un [[cálculo]] o un [[problema abstracto]], es decir, que un número finito de pasos convierten los datos de un problema (entrada) en una solución (salida).<ref name="Brassard" /><ref name="rae"/><ref name="Cormen">{{Cita libro |apellidos=Cormen |nombre=Thomas |enlaceautor=Thomas H. Cormen |título=Introduction to algorithms |año=2009 |editorial=Cambridge, Massachusetts: The [[MIT Press]] |isbn = 978-0-262-53305-8|apellidos2=Leiserson, Charles |apellidos3=Rivest, Ronald |apellidos4=Stein, Clifford}}</ref><ref name="Grimaldi">{{Cita libro |apellidos=Ralph P. Grimaldi |título=Matemáticas Discreta y Combinatoria |año=1998 |editorial=México: Addison Wesley Longman de México |capítulo=Propiedades de los números enteros: Inducción matemática |isbn = 968-444-324-2}}</ref><ref name="Johnsonbaugh">{{Cita libro |apellidos=Johnsonbaugh, Richard |título=Matemáticas Discretas |año=2005 |editorial=México: PEARSON EDUCACIÓN |capítulo=Introducción a la teoría de números |isbn = 970-26-0637-3}}</ref><ref name="Reynolds">{{Cita libro |apellidos=Carl Reynolds & Paul Tymann |título=Schaum's Outline of Principles of Computer Science |año=2008 |editorial=McGraw-Hill |isbn = 978-0-07-146051-4}}</ref> Sin embargo, cabe notar que algunos algoritmos no tienen necesariamente que terminar o resolver un problema en particular. Por ejemplo, una versión modificada de la [[criba de Eratóstenes]], que nunca termine de calcular números primos, no deja de ser un algoritmo.<ref name="Gurevich">{{Cita publicación |url=http://research.microsoft.com/en-us/um/people/gurevich/Opera/141.pdf |título=Sequential Abstract State Machines capture Sequential Algorithms |apellidos=Gurevich, Yuri |volumen=1 |número=1 |páginas=77-111 |issn=1529-3785 |año=2000 |revista=ACM Transactions on Computational Logic}}</ref>

A lo largo de la historia, varios autores han tratado de definir formalmente a los algoritmos utilizando modelos matemáticos. Esto lo hizo [[Alonzo Church]] en 1936 con el concepto de "calculabilidad efectiva" basada en su [[cálculo lambda]] y por [[Alan Turing]] basándose en la [[máquina de Turing]]. Los dos enfoques son equivalentes, en el sentido de que se pueden resolver exactamente los mismos problemas con ambos enfoques.<ref name="savage">{{Cita libro |apellidos=John E. Savage |título=The Complexity of Computing |año=1987 |editorial=Krieger Publishing Co. |isbn=089874833X}}</ref><ref name="sipser">{{Cita libro |apellidos=Sipser |nombre=Michael |título=Introduction to the Theory of Computation |url=http://www-math.mit.edu/~sipser/ |año=2005 |editorial=Course Technology |isbn=978-0534950972 |edición=2 |urlarchivo=https://web.archive.org/web/20060615070738/http://www-math.mit.edu/~sipser/ |fechaarchivo=15 de junio de 2006}}</ref> No obstante, estos modelos están sujetos a un tipo particular de datos, como son números, símbolos o [[Grafo|gráficas]] mientras que, en general, los algoritmos funcionan sobre una vasta cantidad de [[Estructura de datos|estructuras de datos]].<ref name="Cormen" /><ref name="Brassard" /> En general, la parte común en todas las definiciones se puede resumir en las siguientes tres propiedades, siempre y cuando no consideremos [[Algoritmo paralelo|algoritmos paralelos]]:<ref name="Gurevich" />
* Tiempo secuencial. Un algoritmo funciona en tiempo discretizado –paso a paso–, definiendo así una secuencia de estados ''computacionales'' por cada entrada válida (la ''entrada'' son los datos que se le suministran al algoritmo antes de comenzar).
* Estado abstracto. Cada estado computacional puede ser descrito formalmente utilizando una [[Lógica matemática|estructura de primer orden]] y cada algoritmo es independiente de su implementación (los algoritmos son objetos abstractos), de manera que en un algoritmo las estructuras de primer orden son invariantes bajo isomorfismo.
* Exploración acotada. La transición de un estado al siguiente queda completamente determinada por una descripción fija y finita; es decir, entre cada estado y el siguiente solamente se puede tomar en cuenta una cantidad fija y limitada de términos del estado actual.

En resumen, un algoritmo es cualquier cosa que funcione paso a paso, donde cada paso se pueda describir sin ambigüedad y sin hacer referencia a una computadora en particular, y además tiene un límite fijo en cuanto a la cantidad de datos que se pueden leer/escribir en un solo paso.

Esta amplia definición abarca tanto a algoritmos prácticos como aquellos que solo funcionan en teoría, por ejemplo, el [[método de Newton]] y la [[eliminación de Gauss-Jordan]] funcionan, al menos en principio, con números de precisión infinita; sin embargo, no es posible programar la precisión infinita en una computadora, y no por ello dejan de ser algoritmos.<ref name="Dershowitz">{{Cita publicación |url=http://research.microsoft.com/en-us/um/people/gurevich/Opera/188.pdf |título=A natural axiomatization of computability and proof of Church's Thesis |apellidos=Nachum Dershowitz & Yuri Gurevich |volumen=14 |número=3 |páginas=299-350 |issn=1079-8986 |año=2008 |revista=Bulletin of Symbolic Logic}}</ref> En particular es posible considerar una cuarta propiedad que puede usarse para validar la [[tesis de Church-Turing]], de que toda función calculable se puede programar en una máquina de Turing (o equivalentemente, en un lenguaje de programación suficientemente general):<ref name="Dershowitz" />
* Aritmetizabilidad. Solamente operaciones innegablemente calculables están disponibles en el paso inicial.

== Medios de expresión de un algoritmo ==
Los algoritmos pueden ser expresados de muchas maneras, incluyendo al [[lenguaje natural]], [[pseudocódigo]], [[diagramas de flujo]] y [[Lenguaje de programación|lenguajes de programación]] entre otros. Las descripciones en lenguaje natural tienden a ser ambiguas y extensas. El usar pseudocódigo y diagramas de flujo evita muchas ambigüedades del lenguaje natural. Dichas expresiones son formas más estructuradas para representar algoritmos; no obstante, se mantienen independientes de un lenguaje de programación específico.

La descripción de un algoritmo suele hacerse en tres niveles:
# Descripción de alto nivel. Se establece el problema, se selecciona un modelo matemático y se explica el algoritmo de manera verbal, posiblemente con ilustraciones y omitiendo detalles.
# Descripción formal. Se usa un pseudocódigo para describir la secuencia de pasos que encuentran la solución.
# Implementación. Se muestra el algoritmo expresado en un lenguaje de programación específico o algún objeto capaz de llevar a cabo instrucciones.

También es posible incluir un [[teorema]] que demuestre que el algoritmo es correcto, un análisis de complejidad o ambos.

=== Diagrama de flujo ===
[[Archivo:AlgoritmoRaiz.png|thumb|[[Diagrama de flujo]] que expresa un algoritmo para calcular la raíz cuadrada de un número <math>x</math>]]
{{AP|Diagrama de flujo}}
Los diagramas de flujo son descripciones gráficas de algoritmos; usan símbolos conectados con flechas para indicar la secuencia de instrucciones y están regidos por [[Organización Internacional para la Estandarización|ISO]].

Los diagramas de flujo se emplean para representar algoritmos pequeños, ya que abarcan mucho espacio y su construcción es laboriosa. Por su facilidad de lectura se utilizan como introducción a los algoritmos, descripción de un lenguaje y descripción de procesos a personas ajenas a la computación.

=== Pseudocódigo ===
{{AP|Pseudocódigo}}
El pseudocódigo (''falso lenguaje'', el prefijo ''pseudo'' significa ''falso'') es una descripción de alto nivel de un algoritmo que emplea una mezcla de lenguaje natural con algunas convenciones sintácticas propias de lenguajes de programación, como asignaciones, ciclos y condicionales, aunque no está regido por ningún estándar. 

El pseudocódigo está pensado para facilitar a las personas el entendimiento de un algoritmo y, por lo tanto, puede omitir detalles irrelevantes que son necesarios en una implementación. Programadores diferentes suelen utilizar convenciones distintas, que pueden estar basadas en la sintaxis de lenguajes de programación concretos. Sin embargo, el pseudocódigo, en general, es comprensible sin necesidad de conocer o usar un entorno de programación específico, y es a la vez suficientemente estructurado para que su implementación se pueda hacer directamente a partir de él.

Así, el pseudocódigo cumple con las funciones antes mencionadas para representar algo abstracto, los protocolos son los lenguajes para la programación. Busque fuentes más precisas para tener mayor comprensión del tema.

=== Sistemas formales ===
La [[teoría de autómatas]] y la teoría de [[Función recursiva|funciones recursivas]] proveen modelos matemáticos que formalizan el concepto de ''algoritmo''. Los modelos más comunes son la [[máquina de Turing]], [[máquina de registro]] y [[Función recursiva|funciones μ-recursivas]]. Estos modelos son tan precisos como un [[lenguaje máquina]], careciendo de expresiones coloquiales o ambigüedad; sin embargo, se mantienen independientes de cualquier computadora y de cualquier implementación.

=== Implementación ===
Muchos algoritmos se han ideado para implementarse en un [[Programa (computación)|programa]]. No obstante, los algoritmos pueden ser implementados en otros medios, como una [[Red neuronal artificial|red neuronal]], un circuito eléctrico o un aparato mecánico y eléctrico. Algunos algoritmos incluso se diseñan especialmente para implementarse usando lápiz y papel. El [[algoritmo de multiplicación]] tradicional, el [[algoritmo de Euclides]], la [[criba de Eratóstenes]] y muchas [[formas de resolver la raíz cuadrada]] son solo algunos ejemplos.

=== Variables ===
Son elementos que toman valores específicos de un tipo de datos concreto. La declaración de una variable puede realizarse comenzando con '''var'''. Principalmente, existen dos maneras de otorgar valores iniciales a variables: 

# Mediante una sentencia de asignación.
# Mediante un procedimiento de entrada de datos (por ejemplo: 'read').

Ejemplo:

      ...
     i:=1;
     read(n);
     while i < n do begin
        (* cuerpo del bucle *)
        i := i + 1
     end;
      ...

=== Estructuras secuenciales ===
La estructura secuencial es aquella en la que una acción sigue a otra en secuencia. Las operaciones se suceden de tal modo que la salida de una es la entrada de la siguiente y así sucesivamente hasta el fin del proceso.
La asignación de esto consiste en el paso de valores o resultados a una zona de la memoria. Dicha zona será reconocida con el nombre de la variable que recibe el valor. La asignación se puede clasificar de la siguiente forma: 
# Simples: Consiste en pasar un valor constante a una variable (a ← 15)
# Contador: Consiste en usarla como un verificador del número de veces que se realiza un proceso (a ← a + 1) 
# Acumulador: Consiste en usarla como un sumador en un proceso (a ← a + b)
# De trabajo: Donde puede recibir el resultado de una operación matemática que involucre muchas variables (a ← c + b*1/2).
Un ejemplo de estructura secuencial, como obtener el área de un triángulo:

 Inicio 
 ...
     float b, h, a;
     printf("Diga la base");
     scanf("%f", &b);
     printf("Diga la altura");
     scanf("%f", &h);
     a = (b*h)/2;
     printf("El área del triángulo es %f", a)
 ...
 Fin

== Algoritmos como funciones ==
{{AP|Teoría de la computabilidad}}
[[Archivo:EsquemáticaAlgoritmo1.svg|thumb|Esquemática de un algoritmo que soluciona un problema de [[Camino hamiltoniano|ciclo hamiltoniano]]|400 px]]Un algoritmo se puede concebir como una [[Función matemática|función]] que transforma los datos de un [[Problema abstracto|problema]] (entrada) en los datos de una solución (salida). Más aún, los datos se pueden representar a su vez como secuencias de [[bit]]s, y en general, de símbolos cualesquiera.<ref name="Brassard" /><ref name="sipser" /><ref name="Kelley">{{Cita libro |apellidos=Kelley |nombre=Dean |título=Teoría de Autómatas y Lenguajes Formales |url=http://krypton.mnsu.edu/~kelled/ |fechaacceso=23 de noviembre de 2009 |año=1995 |editorial=Prentice Hall |isbn=0-13-497777-7 |urlarchivo=https://web.archive.org/web/20121114162557/http://krypton.mnsu.edu/~kelled/ |fechaarchivo=14 de noviembre de 2012}}</ref> Como cada secuencia de bits representa a un [[número natural]] (véase [[Sistema binario]]), entonces los algoritmos son en esencia funciones de los números naturales en los números naturales que sí se pueden calcular. Es decir que todo algoritmo calcula una función <math>f\colon \mathbb N\to \mathbb N</math> donde cada número natural es la [[Teoría de códigos|codificación]] de un problema o de una solución.

En ocasiones los algoritmos son susceptibles de nunca terminar, por ejemplo, cuando entran a un [[bucle infinito]]. Cuando esto ocurre, el algoritmo nunca devuelve ningún valor de salida, y podemos decir que la función queda indefinida para ese valor de entrada. Por esta razón se considera que los algoritmos son [[Función parcial|funciones parciales]], es decir, no necesariamente definidas en todo su [[dominio de definición]].

Cuando una función puede ser calculada por medios algorítmicos, sin importar la cantidad de memoria que ocupe o el tiempo que se tarde, se dice que dicha función es [[Función computable|computable]]. No todas las funciones entre secuencias datos son computables. El [[problema de la parada]] es un ejemplo.

== Análisis de algoritmos ==
{{AP|Análisis de algoritmos}}
Como medida de la eficiencia de un algoritmo, se suelen estudiar los recursos (memoria y tiempo) que consume el algoritmo. El análisis de algoritmos se ha desarrollado para obtener valores que de alguna forma indiquen (o especifiquen) la evolución del gasto de tiempo y memoria en función del tamaño de los valores de entrada.

El análisis y estudio de los algoritmos es una disciplina de las [[Ciencias_de_la_computacion|ciencias de la computación]] y, en la mayoría de los casos, su estudio es completamente abstracto sin usar ningún tipo de [[lenguaje de programación]] ni cualquier otra implementación; por eso, en ese sentido, comparte las características de las disciplinas matemáticas. Así, el análisis de los algoritmos se centra en los principios básicos del algoritmo, no en los de la implementación particular. Una forma de plasmar (o algunas veces "codificar") un algoritmo es escribirlo en [[pseudocódigo]] o utilizar un lenguaje muy simple tal como [[Lexico]], cuyos códigos pueden estar en el idioma del programador.

Algunos escritores restringen la definición de algoritmo a procedimientos que deben acabar en algún momento, mientras que otros consideran procedimientos que podrían ejecutarse eternamente sin pararse, suponiendo el caso en el que existiera algún dispositivo físico que fuera capaz de funcionar eternamente. En este último caso, la finalización con éxito del algoritmo no se podría definir como la terminación de este con una salida satisfactoria, sino que el éxito estaría definido en función de las secuencias de salidas dadas durante un periodo de vida de la ejecución del algoritmo. Por ejemplo, un algoritmo que verifica que hay más ceros que unos en una secuencia [[código binario|binaria]] infinita debe ejecutarse siempre para que pueda devolver un valor útil. Si se implementa correctamente, el valor devuelto por el algoritmo será válido, hasta que evalúe el siguiente dígito binario. De esta forma, mientras evalúa la siguiente secuencia podrán leerse dos tipos de señales: una señal positiva (en el caso de que el número de ceros sea mayor que el de unos) y una negativa en caso contrario. Finalmente, la salida de este algoritmo se define como la devolución de valores exclusivamente positivos si hay más ceros que unos en la secuencia y, en cualquier otro caso, devolverá una mezcla de señales positivas y negativas.

== Ejemplo de algoritmo ==
El problema consiste en encontrar el máximo de un conjunto de números. Para un ejemplo más complejo véase [[Algoritmo de Euclides]].

=== Descripción de alto nivel ===
Dado un [[conjunto]] finito <math>C</math> de números, se tiene el problema de encontrar el número más grande. Sin pérdida de generalidad se puede asumir que dicho conjunto no es vacío y que sus elementos están numerados como <math>c_0,c_1,\dots,c_n</math>.

Es decir, dado un conjunto <math>C=\{c_0,c_1,\dots,c_n\}</math> se pide encontrar <math>m</math> tal que <math>x\leq m</math> para todo elemento <math>x</math> que pertenece al conjunto <math>C</math>.

Para encontrar el elemento máximo, se asume que el primer elemento (<math>c_0</math>) es el máximo; luego, se recorre el conjunto y se compara cada valor con el valor del máximo número encontrado hasta ese momento. En el caso de que un elemento sea mayor que el máximo, se asigna su valor al máximo. Cuando se termina de recorrer la lista, el máximo número que se ha encontrado es el máximo de todo el conjunto.

=== Descripción formal ===
El algoritmo puede ser escrito de una manera más formal en el siguiente [[pseudocódigo]]:
{{Algoritmo|Encontrar el máximo de un conjunto|
'''función''' max(<math>C</math>)
://<math>C</math> es un conjunto no vacío de números//
:<math>n</math> ← <math>|C|</math> //<math>|C|</math> es el número de elementos de <math>C</math>//
:<math>m</math> ← <math>c_0</math>
:'''para''' <math>i</math> ← <math>1</math> '''hasta''' <math>n</math> '''hacer'''
::'''si''' <math>c_i > m</math> '''entonces'''
:::<math>m</math> ← <math>c_i</math>
:'''devolver''' <math>m</math>
}}

Sobre la notación:
* "←" representa una asignación: <math>m</math> ← <math>x</math> significa que la variable <math>m</math> toma el valor de <math>x</math>;
* "'''devolver'''" termina el algoritmo y devuelve el valor a su derecha (en este caso, el máximo de <math>C</math>).

=== Implementación ===
En lenguaje [[C++]]:
<syntaxhighlight lang="c">
int max(int c[], int n)
{
   int i, m = c[0];
   for (i = 1; i < n; i++)
      if (c[i] > m) m = c[i];
   return m;
}
</syntaxhighlight>

== Véase también ==

=== Tipos de algoritmos según su función ===
* [[Algoritmo de ordenamiento]]
* [[Algoritmo de búsqueda]]

[[Archivo:Selection-Sort-Animation.gif|thumb|ilustración animada del proceso de un algoritmo de ordenación de números.]]

=== Técnicas de diseño de algoritmos ===
* [[Algoritmo voraz|Algoritmos voraces]] (greedy): seleccionan los elementos más prometedores del conjunto de candidatos hasta encontrar una solución. En la mayoría de los casos la solución no es óptima.
* [[Algoritmos paralelos]]: permiten la división de un problema en subproblemas de forma que se puedan ejecutar de forma simultánea en varios procesadores.
* [[Algoritmo probabilístico|Algoritmos probabilísticos]]: algunos de los pasos de este tipo de algoritmos están en función de valores [[pseudoaleatoriedad|pseudoaleatorios]].
* [[Algoritmo determinístico|Algoritmos determinísticos]]: el comportamiento del algoritmo es lineal: cada paso del algoritmo tiene únicamente un paso sucesor y otro antecesor.
* [[Algoritmo no determinístico|Algoritmos no determinísticos]]: el comportamiento del algoritmo tiene forma de árbol y a cada paso del algoritmo puede bifurcarse a cualquier número de pasos inmediatamente posteriores, además todas las ramas se ejecutan simultáneamente.
* [[Divide y vencerás]]: dividen el problema en subconjuntos disjuntos obteniendo una solución de cada uno de ellos para después unirlas, logrando así la solución al problema completo.
* [[Metaheurísticas]]: encuentran soluciones aproximadas (no óptimas) a problemas basándose en un conocimiento anterior (a veces llamado experiencia) de los mismos.
* [[Programación dinámica (computación)|Programación dinámica]]: intenta resolver problemas disminuyendo su coste computacional aumentando el coste espacial.
* [[Ramificación y acotación]]: se basa en la construcción de las soluciones al problema mediante un árbol implícito que se recorre de forma controlada encontrando las mejores soluciones.
* [[Vuelta atrás]] (backtracking): se construye el espacio de soluciones del problema en un árbol que se examina completamente, almacenando las soluciones menos costosas.

=== Temas relacionados ===
* [[Cota inferior asintótica]]
* [[Cota ajustada asintótica]]
* [[Complejidad computacional]]
* [[Diagrama de flujo|Diagramas de flujo]]
* [[Diagrama Nassi-Shneiderman]]
* [[Máquina de Turing]]

=== Disciplinas relacionadas ===
* [[Ciencias de la Computación]]
* [[Análisis de algoritmos]]
* [[Complejidad computacional]]
* [[Gobierno por algoritmos]]
* [[Informática]]
* [[Inteligencia artificial]]
* [[Investigación operativa]]
* [[Matemáticas]]
* [[Programación]]

== Referencias ==
{{Listaref}}

== Bibliografía ==
* Aho, A. ''The Design and Analysis of Computer Algorithms''
* Cormen, T. H., Leiserson, C. E., [[Rivest, R. L.]] y Stein, C. ''Introduction to Algorithms (2nd ed.)''
* [[Gilles Brassard|Brassard, G.]] y P. Bratley. ''Fundamentos de Algoritmia'', (ISBN 848966000X)
* [[Knuth, D. E]]. ''The Art of Computer Programming'', [quien fue también, el creador del [[TeX]]]
* Mamber, U. ''Introduction to Algorithms. A Creative Approach''
* Sedgewick, R. ''Algorithms in C (3r ed)'' (también existen versiones en C++ y [[Lenguaje de programación Java|Java]])
* {{cite journal | last1 = Axt | first1 = P | year = 1959 | title = On a Subrecursive Hierarchy and Primitive Recursive Degrees | journal = Transactions of the American Mathematical Society | volume = 92 | issue = 1| pages = 85–105 | doi=10.2307/1993169| jstor = 1993169 | doi-access = }}
* Bell, C. Gordon and Newell, Allen (1971), ''Computer Structures: Readings and Examples'', McGraw–Hill Book Company, New York. {{ISBN|0-07-004357-4}}.
* {{Cite journal|author1-link=|first1=Andreas|last1=Blass|author2-link=Yuri Gurevich|first2=Yuri|last2=Gurevich|year=2003|url=http://research.microsoft.com/~gurevich/Opera/164.pdf|title=Algorithms: A Quest for Absolute Definitions|journal= Bulletin of European Association for Theoretical Computer Science|volume= 81}} Includes an excellent bibliography of 56 references.
* {{cite book| last = Bolter| first = David J.| title = Turing's Man: Western Culture in the Computer Age| url = https://archive.org/details/turingsmanwester0000bolt| edition = 1984| year = 1984| publisher = The University of North Carolina Press|location= Chapel Hill, NC| isbn = 978-0-8078-1564-9 }}, {{ISBN|0-8078-4108-0}}
* {{cite book| last1 = Boolos| first1 = George| last2 = Jeffrey| first2 = Richard| title = Computability and Logic| url = https://archive.org/details/computabilitylog0000bool_r8y9| url-access = registration| edition = 4th| orig-year = | year = 1999| publisher = Cambridge University Press, London| isbn = 978-0-521-20402-6| author1-link = George Boolos| author2-link = Richard Jeffrey }}: cf. Chapter 3 ''Turing machines'' where they discuss "certain enumerable sets not effectively (mechanically) enumerable".
* {{cite book| last = Burgin| first = Mark| title = Super-Recursive Algorithms| year = 2004| publisher = Springer| isbn = 978-0-387-95569-8 }}
* Campagnolo, M.L., [[Cris Moore|Moore, C.]], and Costa, J.F. (2000) An analog characterization of the subrecursive functions. In ''Proc. of the 4th Conference on Real Numbers and Computers'', Odense University, pp.&nbsp;91–109
* {{Cite journal|last=Church|first=Alonzo|author-link=Alonzo Church|title=An Unsolvable Problem of Elementary Number Theory|journal=The American Journal of Mathematics|volume=58|pages= 345–363|year=1936a|doi=10.2307/2371045|issue=2|jstor=2371045}} Reprinted in ''The Undecidable'', p.&nbsp;89ff. The first expression of "Church's Thesis". See in particular page 100 (''The Undecidable'') where he defines the notion of "effective calculability" in terms of "an algorithm", and he uses the word "terminates", etc.
* {{Cite journal|last=Church|first=Alonzo|author-link=Alonzo Church|title=A Note on the Entscheidungsproblem|journal=The Journal of Symbolic Logic|volume=1|year=1936b|pages=40–41|doi=10.2307/2269326|issue=1|jstor=2269326}} {{cite journal|last=Church|first=Alonzo|title=Correction to a Note on the Entscheidungsproblem|journal=The Journal of Symbolic Logic|volume=1|year=1936|pages=101–102|doi=10.2307/2269030|issue=3|jstor=2269030}} Reprinted in ''The Undecidable'', p.&nbsp;110ff. Church shows that the Entscheidungsproblem is unsolvable in about 3 pages of text and 3 pages of footnotes.
* {{cite book| last = Daffa'| first = Ali Abdullah al-| title = The Muslim contribution to mathematics| year = 1977| publisher = Croom Helm| location = London| isbn = 978-0-85664-464-1 }}
* {{cite book| last = Davis| first = Martin| author-link = Martin Davis (mathematician)| title = The Undecidable: Basic Papers On Undecidable Propositions, Unsolvable Problems and Computable Functions| url = https://archive.org/details/undecidablebasic0000davi| url-access = registration| year = 1965| publisher = Raven Press| location = New York| isbn = 978-0-486-43228-1 }} Davis gives commentary before each article. Papers of [[Gödel]], [[Alonzo Church]], [[Alan Turing|Turing]], [[J. Barkley Rosser|Rosser]], [[Kleene]], and [[Emil Post]] are included; those cited in the article are listed here by author's name.
* {{cite book| last = Davis| first = Martin| author-link = Martin Davis (mathematician)| title = Engines of Logic: Mathematicians and the Origin of the Computer| year = 2000| publisher = W.W. Nortion| location = New York| isbn = 978-0-393-32229-3 }} Davis offers concise biographies of [[Gottfried Leibniz|Leibniz]], [[George Boole|Boole]], [[Gottlob Frege|Frege]], [[Georg Cantor|Cantor]], [[David Hilbert|Hilbert]], Gödel and Turing with [[John von Neumann|von Neumann]] as the show-stealing villain. Very brief bios of [[Joseph-Marie Jacquard]], [[Babbage]], [[Ada Lovelace]], [[Claude Shannon]], [[Howard Aiken]], etc.
* {{cite journal|title= Evolution and moral diversity |author=Dean, Tim |journal=Baltic International Yearbook of Cognition, Logic and Communication|year=2012|volume=7|doi=10.4148/biyclc.v7i0.1775 |doi-access=}}
* {{cite book| last = Dennett| first = Daniel| author-link = | title = Darwin's Dangerous Idea| journal = Complexity| volume = 2| issue = 1| pages = [https://archive.org/details/darwinsdangerous0000denn/page/32 32]–36| year = 1995| publisher = Touchstone/Simon & Schuster| location = New York| isbn = 978-0-684-80290-9| bibcode = 1996Cmplx...2a..32M| doi = 10.1002/(SICI)1099-0526(199609/10)2:1<32::AID-CPLX8>3.0.CO;2-H| url = https://archive.org/details/darwinsdangerous0000denn| url-access = registration}}
* {{cite book| last = Dilson| first = Jesse| title = The Abacus| edition = (1968, 1994)| year = 2007| publisher = St. Martin's Press, NY| isbn = 978-0-312-10409-2| url = https://archive.org/details/abacusworldsfirs0000dils}}, {{ISBN|0-312-10409-X}}
* [[Yuri Gurevich]], [http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.146.3017&rep=rep1&type=pdf ''Sequential Abstract State Machines Capture Sequential Algorithms''], ACM Transactions on Computational Logic, Vol 1, no 1 (July 2000), pp.&nbsp;77–111. Includes bibliography of 33 sources.
* {{cite book| last = van Heijenoort| first = Jean| author-link = Jean van Heijenoort| title = From Frege to Gödel, A Source Book in Mathematical Logic, 1879–1931| edition = (1967)| year = 2001| publisher = Harvard University Press, Cambridge| isbn = 978-0-674-32449-7 }}, 3rd edition 1976[?], {{ISBN|0-674-32449-8}} (pbk.)
* {{cite book| last = Hodges| first = Andrew| author-link = Andrew Hodges| title = Alan Turing: The Enigma| journal = Physics Today| volume = 37| issue = 11| pages = 107–108| year = 1983| publisher = [[Simon and Schuster]]| location = New York| isbn = 978-0-671-49207-6| title-link = | bibcode = 1984PhT....37k.107H| doi = 10.1063/1.2915935}}, {{ISBN|0-671-49207-1}}. Cf. Chapter "The Spirit of Truth" for a history leading to, and a discussion of, his proof.
* {{Cite journal|last=Kleene|first=Stephen C.|author-link=Stephen Kleene|title=General Recursive Functions of Natural Numbers|journal=Mathematische Annalen|volume=112|pages=727–742|url=http://gdz.sub.uni-goettingen.de/index.php?id=11&PPN=GDZPPN002278499&L=1|year=1936|doi=10.1007/BF01565439|issue=5|s2cid=120517999|access-date=2013-09-30|archive-url=https://web.archive.org/web/20140903092121/http://gdz.sub.uni-goettingen.de/index.php?id=11&PPN=GDZPPN002278499&L=1|archive-date=2014-09-03|url-status=}} Presented to the American Mathematical Society, September 1935. Reprinted in ''The Undecidable'', p.&nbsp;237ff. Kleene's definition of "general recursion" (known now as mu-recursion) was used by Church in his 1935 paper ''An Unsolvable Problem of Elementary Number Theory'' that proved the "decision problem" to be "undecidable" (i.e., a negative result).
* {{Cite journal|last=Kleene|first=Stephen C.|author-link=Stephen Kleene |title= Recursive Predicates and Quantifiers|journal=American Mathematical Society Transactions|volume=54|pages=41–73|year=1943 |doi= 10.2307/1990131|issue=1|jstor=1990131|doi-access=}} Reprinted in ''The Undecidable'', p.&nbsp;255ff. Kleene refined his definition of "general recursion" and proceeded in his chapter "12. Algorithmic theories" to posit "Thesis I" (p.&nbsp;274); he would later repeat this thesis (in Kleene 1952:300) and name it "Church's Thesis"(Kleene 1952:317) (i.e., the [[Church thesis]]).
* {{cite book| last = Kleene| first = Stephen C.| author-link = Kleene| title = Introduction to Metamathematics| edition = Tenth|year= 1991| orig-year = | publisher = North-Holland Publishing Company| isbn = 978-0-7204-2103-3 }}
* {{cite book| last = Knuth| first = Donald| author-link = Donald Knuth| title = Fundamental Algorithms, Third Edition| year = 1997| publisher = Addison–Wesley| location = Reading, Massachusetts| isbn = 978-0-201-89683-1 }}
* {{Cite book|last=Knuth|first=Donald|author-link=Donald Knuth|title=Volume 2/Seminumerical Algorithms, The Art of Computer Programming First Edition|publisher=Addison–Wesley|location=Reading, Massachusetts|year=1969}}
* Kosovsky, N.K. ''Elements of Mathematical Logic and its Application to the theory of Subrecursive Algorithms'', LSU Publ., Leningrad, 1981
* {{Cite journal|last=Kowalski|first=Robert|author-link=Robert Kowalski|title=Algorithm=Logic+Control|journal=[[Communications of the ACM]]|volume=22|issue=7|pages=424–436|year=1979|doi=10.1145/359131.359136|s2cid=2509896}}
* [[A.A. Markov]] (1954) ''Theory of algorithms''. [Translated by Jacques J. Schorr-Kon and PST staff] Imprint Moscow, Academy of Sciences of the USSR, 1954 [i.e., Jerusalem, Israel Program for Scientific Translations, 1961; available from the Office of Technical Services, U.S. Dept. of Commerce, Washington] Description 444 p.&nbsp;28&nbsp;cm. Added t.p. in Russian Translation of Works of the Mathematical Institute, Academy of Sciences of the USSR, v.&nbsp;42. Original title: Teoriya algerifmov. [QA248.M2943 Dartmouth College library. U.S. Dept. of Commerce, Office of Technical Services, number OTS .]
* {{cite book| last = Minsky| first = Marvin| author-link = Marvin Minsky| title = Computation: Finite and Infinite Machines| url = https://archive.org/details/computationfinit0000mins| url-access = registration| edition = First| year = 1967| publisher = Prentice-Hall, Englewood Cliffs, NJ| isbn = 978-0-13-165449-5 }} Minsky expands his "...idea of an algorithm – an effective procedure..." in chapter 5.1 ''Computability, Effective Procedures and Algorithms. Infinite machines.''
* {{Cite journal|last=Post|first=Emil|author-link=Emil Post|title=Finite Combinatory Processes, Formulation I |journal=The Journal of Symbolic Logic |volume=1 |year=1936 |pages=103–105 |doi=10.2307/2269031 |issue=3 |jstor=2269031}} Reprinted in ''The Undecidable'', pp.&nbsp;289ff. Post defines a simple algorithmic-like process of a man writing marks or erasing marks and going from box to box and eventually halting, as he follows a list of simple instructions. This is cited by Kleene as one source of his "Thesis I", the so-called [[Church–Turing thesis]].
* {{Cite book|last=Rogers, Jr|first=Hartley|title=Theory of Recursive Functions and Effective Computability|publisher=The MIT Press|year=1987|isbn=978-0-262-68052-3}}
* {{Cite journal|last=Rosser|first=J.B.|author-link=J. B. Rosser|title=An Informal Exposition of Proofs of Godel's Theorem and Church's Theorem|journal=Journal of Symbolic Logic|volume= 4 |issue=2|year=1939|doi=10.2307/2269059|pages=53–60|jstor=2269059}} Reprinted in ''The Undecidable'', p.&nbsp;223ff. Herein is Rosser's famous definition of "effective method": "...a method each step of which is precisely predetermined and which is certain to produce the answer in a finite number of steps... a machine which will then solve any problem of the set with no human intervention beyond inserting the question and (later) reading the answer" (p.&nbsp;225–226, ''The Undecidable'')
* {{cite book |last=Santos-Lang |first=Christopher | year=2014 |editor1-first=Simon |editor1-last=  |editor2-first=Matthijs |editor2-last=Pontier |title=Machine Medical Ethics |volume=74 |publisher=Springer | location=Switzerland | pages=111–127 | chapter=Moral Ecology Approaches to Machine Ethics| chapter-url=http://grinfree.com/MoralEcology.pdf | doi=10.1007/978-3-319-08108-3_8|series=Intelligent Systems, Control and Automation: Science and Engineering |isbn=978-3-319-08107-6 }}
* {{Cite book|last=Scott|first=Michael L.|title=Programming Language Pragmatics |edition=3rd |publisher=Morgan Kaufmann Publishers/Elsevier|year=2009|isbn=978-0-12-374514-9}}
* {{cite book| last = Sipser| first = Michael| title = Introduction to the Theory of Computation| year = 2006| publisher = PWS Publishing Company| isbn = 978-0-534-94728-6| url = https://archive.org/details/introductiontoth00sips}}
* {{cite book |last1=Sober |first1=Elliott |last2=Wilson |first2=David Sloan |year=1998 |title=Unto Others: The Evolution and Psychology of Unselfish Behavior |url=https://archive.org/details/untoothersevolut00sobe |url-access=registration |location=Cambridge |publisher=Harvard University Press}}
* {{Cite book|last=Stone|first=Harold S.|title=Introduction to Computer Organization and Data Structures|url=https://archive.org/details/introductiontoco0000ston|edition=1972|publisher=McGraw-Hill, New York|isbn=978-0-07-061726-1|year=1972}} Cf. in particular the first chapter titled: ''Algorithms, Turing Machines, and Programs''. His succinct informal definition: "...any sequence of instructions that can be obeyed by a robot, is called an ''algorithm''" (p.&nbsp;4).
* {{cite book| last = Tausworthe| first = Robert C| title = Standardized Development of Computer Software Part 1 Methods| year = 1977| publisher = Prentice–Hall, Inc.| location = Englewood Cliffs NJ| isbn = 978-0-13-842195-3 }}
* {{Cite journal|last=Turing|first=Alan M.|author-link=A. M. Turing|title=On Computable Numbers, With An Application to the Entscheidungsproblem|journal=[[Proceedings of the London Mathematical Society]]|series=Series 2|volume=42|pages= 230–265 |year=1936–37|doi=10.1112/plms/s2-42.1.230 }}. Corrections, ibid, vol. 43(1937) pp.&nbsp;544–546. Reprinted in ''The Undecidable'', p.&nbsp;116ff. Turing's famous paper completed as a Master's dissertation while at King's College Cambridge UK.
* {{Cite journal|last=Turing|first=Alan M.|author-link=A. M. Turing|title=Systems of Logic Based on Ordinals|journal=Proceedings of the London Mathematical Society|volume=45|pages=161–228|year=1939|doi=10.1112/plms/s2-45.1.161|hdl=|hdl-access=}} Reprinted in ''The Undecidable'', pp.&nbsp;155ff. Turing's paper that defined "the oracle" was his PhD thesis while at Princeton.
* [[United States Patent and Trademark Office]] (2006), [http://www.uspto.gov/web/offices/pac/mpep/documents/2100_2106_02.htm ''2106.02 **>Mathematical Algorithms: 2100 Patentability''], Manual of Patent Examining Procedure (MPEP). Latest revision August 2006

== Enlaces externos ==
{{wikibooks|Algoritmia}}
{{wikcionario|algoritmo}}

{{Control de autoridades}}
[[Categoría:Algoritmos| ]]
[[Categoría:Arabismos]]